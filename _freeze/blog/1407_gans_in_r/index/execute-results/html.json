{
  "hash": "34b532eeb7365d3f52177ad7a60cdf3d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Illustrative GANs for simple synthetic data with `keras` in `R`\"\nauthor: \"Thom Benjamin Volker\"\ndescription: \"GANs can be hard to get your head around. In this blogpost, I explain GANs using some simple examples and show how to generate samples from these in `R`.\"\ntoc: true\nword-count: true\ndate: 2025-07-14\ncategories: [machine learning, generative adversarial networks, deep learning]\neditor: \n  markdown:\n    wrap: sentence\n---\n\nGenerative adversarial networks (GANs) are a class of machine learning models that can be used to generate synthetic data. To do this, it transforms random noise into data that is similar to the training data. GANs consist of two neural networks: a generator and a discriminator. The generator takes random noise as input and transforms it into synthetic data, while the discriminator tries to distinguish between real and synthetic data. The two networks are trained simultaneously, in a zero-sum game: if the generator generates more realistic synthetic data, the discriminator has more difficulty distinguishing between the real and synthetic data.\n\n\n::: {.cell}\n::: {#fig-gan .cell-output-display}\n\n```{=html}\n<div class=\"grViz html-widget html-fill-item\" id=\"htmlwidget-589f314e0ee959bd9950\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-589f314e0ee959bd9950\">{\"x\":{\"diagram\":\"digraph {\\n  graph [layour = dot, rankdir = LR, bgcolor = \\\"#fffbf2\\\"]\\n  \\n  node [shape = rectangle, style = filled, fillcolor = lightblue]\\n  N1 [label = \\\"Random noise\\\"]\\n  N2 [label = \\\"Generator\\\"]\\n  N3 [label = \\\"Synthetic data\\\"]\\n  N4 [label = \\\"Discriminator\\\"]\\n\\n  N1 -> N2 -> N3 -> N4 -> N2\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n\nGraphical representation of a GAN.\n:::\n:::\n\n\n\n\n# Simple univariate GANs\n\nLet's create a GAN using `keras` and `tensorflow` in `R`. We will use a very simple dataset, consisting of only a single variable that is normally distributed with mean $\\mu = 2$ and standard deviation $\\sigma = 4$. The generator will be a simple linear model, and the discriminator will be a simple feedforward neural network with a single hidden layer.\nThe GAN architecture is inspired by the book [Deep Learning with R](https://www.manning.com/books/deep-learning-with-r).\n\n## Preliminaries\n\nFirst, we load the required packages and generate some training data that we want to synthesize. We generate $n = 1000$ samples from a normal distribution with mean $\\mu = 2$ and standard deviation $\\sigma = 4$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keras3)\nlibrary(tensorflow)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'tensorflow' was built under R version 4.5.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'tensorflow'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:keras3':\n\n    set_random_seed, shape\n```\n\n\n:::\n\n```{.r .cell-code}\nset.seed(123)\nset_random_seed(123)\n\nN <- 1000\ntrain_dat <- matrix(rnorm(N, 2, 4))\n\nplot(density(train_dat), col = \"darkorange2\")\ncurve(dnorm(x, 2, 4), add = TRUE)\n```\n\n::: {.cell-output-display}\n![Distribution of the true data-generating mechanism (black line) and the estimated density of the training data (orange line).](index_files/figure-html/fig-normal-density-1.png){#fig-normal-density width=672}\n:::\n:::\n\n\n## A very simple GAN\n\nTo generate synthetic data, we define a very simple GAN, using a generator that is a simple linear model, and a discriminator that is a model equivalent to a logistic regression model. We define the generator and discriminator as functions that return the respective models. We then define the GAN as a new model class.\n\n### Generator\n\nThe generator consists of only an output layer with a single unit and a linear activation function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerator <- function(latent_dim = 1) {\n  model <- keras_model_sequential(input_shape = latent_dim, name = \"seq_gen\") |> \n    layer_dense(units = 1, activation = \"linear\")\n}\n\nsummary(generator())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_gen\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense (Dense)                     │ (None, 1)                │             2 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 2 (8.00 B)\n Trainable params: 2 (8.00 B)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\n### Discriminator\n\nThe discriminator consists of a single hidden layer with 8 units and rectified linear activation function, and an output layer with a single unit and a sigmoid activation function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminator <- function(dim = 1) {\n  model <- keras_model_sequential(input_shape = dim, name = \"seq_disc\") |> \n    layer_dense(units = 8, activation = \"relu\") |>\n    layer_dense(units = 1, activation = \"sigmoid\")\n}\n\nsummary(discriminator())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_disc\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_1 (Dense)                   │ (None, 8)                │            16 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_2 (Dense)                   │ (None, 1)                │             9 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 25 (100.00 B)\n Trainable params: 25 (100.00 B)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\n### Defining a GAN model class\n\nNow we have everything in place, we can define a new model class which collects the generator, discriminator and additional hyperparameters. We also define the training step for the GAN.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngan <- new_model_class(\n  classname = \"GAN\",\n  # initialize model with generator, discriminator, dimension\n  # of the random latent vectors (i.e., the input that is \n  # transformed by the generator to yield useful synthetic \n  # data).\n  initialize = function(discriminator, generator, latent_dim) {\n    super$initialize()\n    self$discriminator <- discriminator\n    self$generator <- generator\n    self$latent_dim <- latent_dim\n    self$d_loss_metric <- metric_mean(name = \"d_loss\")\n    self$g_loss_metric <- metric_mean(name = \"g_loss\")\n  },\n  # create compile function that sets the optimizers and loss\n  compile = function(d_optimizer, g_optimizer, loss_fn) {\n    super$compile()\n    self$d_optimizer <- d_optimizer\n    self$g_optimizer <- g_optimizer\n    self$loss_fn <- loss_fn\n  },\n  # plot generator and discriminator loss during training\n  metrics = mark_active(function() {\n    list(self$d_loss_metric, self$g_loss_metric)\n  }),\n  # define the training step, set batch size, create random normal variates\n  # as input for the generator, stack real and generated data, create labels\n  # for the discriminator, add some noise to the labels to prevent overfitting,\n  # compute discriminator loss, compute gradients, apply gradients to the\n  # discriminator.\n  train_step = function(real_data) {\n    batch_size <- tf$shape(real_data)[1]\n    random_latent_vectors <- tf$random$normal(shape = c(batch_size, self$latent_dim))\n    generated_data <- self$generator(random_latent_vectors)\n    combined_data <- tf$concat(list(generated_data, real_data), axis = 0L)\n    labels <- tf$concat(list(tf$ones(tuple(batch_size, 1L)),\n                             tf$zeros(tuple(batch_size, 1L))), axis = 0L)\n    labels <- labels + tf$random$uniform(tf$shape(labels), maxval = 0.01)\n    \n    with(tf$GradientTape() %as% tape, {\n      predictions <- self$discriminator(combined_data)\n      d_loss <- self$loss_fn(labels, predictions)\n    })\n    \n    grads <- tape$gradient(d_loss, self$discriminator$trainable_weights)\n    \n    self$d_optimizer$apply_gradients(\n      zip_lists(grads, self$discriminator$trainable_weights)\n    )\n    \n    # Then sample new random points in latent space, and create labels as if all\n    # these new samples were real so that only the generator is trained, and not\n    # the discriminator. Then the generator loss is computed, and the generator \n    # weights are updated. \n    \n    random_latent_vectors <- tf$random$normal(shape = c(batch_size, self$latent_dim))\n    misleading_labels <- tf$zeros(tuple(batch_size, 1L))\n    with(tf$GradientTape() %as% tape, {\n      predictions <- random_latent_vectors |>\n        self$generator() |>\n        self$discriminator()\n      g_loss <- self$loss_fn(misleading_labels, predictions)\n    })\n    \n    grads <- tape$gradient(g_loss, self$generator$trainable_weights)\n    self$g_optimizer$apply_gradients(\n      zip_lists(grads, self$generator$trainable_weights)\n    )\n    \n    self$d_loss_metric$update_state(d_loss)\n    self$g_loss_metric$update_state(g_loss)\n    list(d_loss = self$d_loss_metric$result(),\n         g_loss = self$g_loss_metric$result())\n  }\n)\n```\n:::\n\n\n### Training the GAN\n\nWe assemble all pieces and train the GAN. We use a simple standard normal distribution $\\mathcal{N}(0, 1)$ as the latent input data for the generator. We first train the GAN for 250 epochs, and store the result after every twentieth epoch.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatent_dim <- as.integer(1)\nnsyn <- nrow(train_dat)\n\nmod <- gan(\n  discriminator = discriminator(dim = ncol(train_dat)), \n  generator = generator(latent_dim = latent_dim), \n  latent_dim = latent_dim\n)\n\nmod |>\n  compile(\n    d_optimizer = optimizer_adam(beta_1 = 0.5),\n    g_optimizer = optimizer_adam(beta_1 = 0.5),\n    loss_fn = loss_binary_crossentropy()\n  )\n\nplot(\n  density(train_dat), \n  ylim = c(0, 0.2), \n  xlim = c(-12, 16), \n  col = \"darkorange2\",\n  xlab = \"x\",\n  main = \"GAN Training\"\n)\n\ncurve(dnorm(x, 2, 4), add = TRUE)\ncurve(dnorm(x, 0, 1), add = TRUE, col = \"black\", lty=2)\n\nfor (i in 1:5) {\n  mod |>\n    fit(train_dat, epochs = 30, batch_size = 32, verbose = 0)\n  newdat <- mod$generator(tf$random$normal(shape = c(nsyn, latent_dim)))\n  lines(density(as.matrix(newdat)), \n        col = RColorBrewer::brewer.pal(7, \"Greens\")[i])\n}\n```\n\n::: {.cell-output-display}\n![Synthetic data distributions after training the GAN for 30, 60, 90, 120 and 150 epochs (light green to dark green lines), the data-generating distribution (solid black line), the random normal input data (dashed black line) and the observed data, target, density (orange line).](index_files/figure-html/fig-simple-normal-gan-training-1.png){#fig-simple-normal-gan-training width=672}\n:::\n:::\n\n@fig-simple-normal-gan-training shows the density of the training data (orange), the true data generating distribution (black line), the distribution of the random input vectors (black dashed line), and the density of the generated data after 30, 60, 90, 120 and 150 epochs of training (green lines). The generator comes increasingly close to the true data generating distribution.\n\n\n## A normal mixture GAN\n\nIn this example, we will use a more complex data generating distribution. We will use a mixture of two normal distributions with means $\\mu_1 = 2$ and $\\mu_2 = 8$, and standard deviations $\\sigma_1 = 1$ and $\\sigma_2 = 2$. The data generating distribution is then given by\n$$\nf(x) = 0.5 \\cdot \\mathcal{N}(x; 2, 1) + 0.5 \\cdot \\mathcal{N}(x; 8, 2).\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixture <- rbinom(N, 1, 0.5)\ntrain_dat <- matrix(mixture * rnorm(N, 2, 1) + (1 - mixture) * rnorm(N, 8, 2))\n\nplot(density(train_dat), ylim = c(0, 0.2), col = \"darkorange2\")\ncurve(0.5 * dnorm(x, 2, 1) + 0.5 * dnorm(x, 8, 2), add = TRUE)\n```\n\n::: {.cell-output-display}\n![Distribution of the true data-generating mechanism (black line) and the estimated density of the training data (orange line).](index_files/figure-html/fig-mixture-density-1.png){#fig-mixture-density width=672}\n:::\n:::\n\n\nWe can now train the GAN on this data generating distribution. We slightly change the generator and discriminator architectures to allow for a more complex data generating distribution. We also increase the number of epochs to 500.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerator <- function(latent_dim = 1) {\n  model <- keras_model_sequential(input_shape = latent_dim, name = \"seq_gen\") |> \n    layer_dense(units = 16, activation = \"relu\") |>\n    layer_dense(units = 1, activation = \"linear\")\n}\n\nsummary(generator())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_gen\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_6 (Dense)                   │ (None, 16)               │            32 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_7 (Dense)                   │ (None, 1)                │            17 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 49 (196.00 B)\n Trainable params: 49 (196.00 B)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\nThe generator now has a single hidden layer with 16 units and rectified linear activation function, and a single output layer with linear activation function. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminator <- function(dim = 1) {\n  model <- keras_model_sequential(input_shape = dim, name = \"seq_disc\") |> \n    layer_dense(units = 32, activation = \"relu\") |>\n    layer_dense(units = 16, activation = \"relu\") |>\n    layer_dense(units = 1, activation = \"sigmoid\")\n}\n\nsummary(discriminator())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_disc\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_8 (Dense)                   │ (None, 32)               │            64 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_9 (Dense)                   │ (None, 16)               │           528 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_10 (Dense)                  │ (None, 1)                │            17 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 609 (2.38 KB)\n Trainable params: 609 (2.38 KB)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\nThe discriminator has two hidden layers with 32 and 16 units, respectively, and rectified linear activation functions. The output layer has a single unit and a sigmoid activation function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatent_dim <- as.integer(1)\nnsyn <- nrow(train_dat)\n\nmod <- gan(\n  discriminator = discriminator(dim = ncol(train_dat)), \n  generator = generator(latent_dim = latent_dim), \n  latent_dim = latent_dim\n)\n\nmod |>\n  compile(\n    d_optimizer = optimizer_adam(beta_1 = 0.5),\n    g_optimizer = optimizer_adam(beta_1 = 0.5),\n    loss_fn = loss_binary_crossentropy()\n  )\n\n\nplot(\n  density(train_dat), \n  ylim = c(0, 0.2), \n  col = \"darkorange2\",\n  xlab = \"x\",\n  main = \"GAN Training\"\n)\ncurve(0.5 * dnorm(x, 2, 1) + 0.5 * dnorm(x, 8, 2), add = TRUE)\n\n\nfor (i in 1:5) {\n  mod |>\n    fit(train_dat, epochs = 100, batch_size = 32, verbose = 0)\n  newdat <- mod$generator(tf$random$normal(shape = c(nsyn, latent_dim)))\n  lines(density(as.matrix(newdat)), \n        col = RColorBrewer::brewer.pal(6, \"Greens\")[i])\n}\n```\n\n::: {.cell-output-display}\n![Synthetic data distributions after training the GAN for 100, 200, 300, 400 and 500 epochs (light green to dark green lines), the data-generating distribution (black line) and the observed data, target, density (orange line).](index_files/figure-html/fig-mixture-normal-gan-training-1.png){#fig-mixture-normal-gan-training width=672}\n:::\n:::\n\n\nWe still use only a single random latent dimension, and train the model for 100, 200, 300, 400 and 500 epochs with a batch size of 32. @fig-mixture-normal-gan-training shows the true data generating distribution (black dashed line) and the density of the training data (orange) and the generated data (darker green denotes later epochs). The generator comes increasingly close to the true data generating distribution.\n\n## Conclusion\n\nIn the first section, we illustrated some very basic GANs and showed how these can be used to generate synthetic univariate data. The illustrations showed that as the complexity of the data increases, the GANs need to be more complex to capture the data generating distribution. In the next section, we will illustrate how GANs can be used to generate multivariate data.\n\n# GANs for multivariate data\n\nFor the multivariate case, the general set-up remains pretty similar. We still need a generator and a discriminator, but we make some changes to the architecture of these models.\n\n## Modeleling a bivariate normal distribution\n\nWe start this section by modeling a bivariate normal distribution. The data generating distribution is given by\n$$\nf(x_1, x_2) = \\mathcal{N}((x_1, x_2); (2, 2), \\begin{pmatrix} 1 & 0.5 \\\\ 0.5 & 1 \\end{pmatrix}).\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nP <- 2\nmu <- c(2,2)\nSigma <- matrix(c(1, 0.5, 0.5, 1), nrow = 2)\n\ntrain_dat <- rnorm(N*P) |> \n  matrix(N) %*%\n  chol(Sigma) + rep(mu, each = N)\n\nplot(train_dat, col = \"darkorange2\", xlab = \"x1\", ylab = \"x2\")\ncontour(\n  x = seq(-2, 6, length = 100), \n  y = seq(-2, 6, length = 100), \n  z = matrix(mvtnorm::dmvnorm(expand.grid(x = seq(-2, 6, length = 100), \n                                          y = seq(-2, 6, length = 100)), \n                              mu, Sigma), nrow = 100),\n  add = TRUE\n)\n```\n\n::: {.cell-output-display}\n![Density of the true data-generating mechanism (black line) and the estimated density of the training data (orange line).](index_files/figure-html/fig-bivariate-normal-density-1.png){#fig-bivariate-normal-density width=672}\n:::\n:::\n\n\n@fig-bivariate-normal-density shows the contour line of true data generating distribution (black lines) and the realized training data (orange points). We can now train a GAN on this data generating distribution. We start by defining the generator and discriminator architectures.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerator <- function(latent_dim = 1) {\n  model <- keras_model_sequential(input_shape = latent_dim, name = \"seq_gen\") |> \n    layer_dense(units = 2, activation = \"linear\")\n}\n\ngenerator() |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_gen\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_16 (Dense)                  │ (None, 2)                │             4 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 4 (16.00 B)\n Trainable params: 4 (16.00 B)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\nThe generator has a single hidden layer with 16 units and rectified linear activation function, and an output layer with two units and linear activation function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminator <- function(dim = 2) {\n  model <- keras_model_sequential(input_shape = dim, name = \"seq_disc\") |> \n    layer_dense(units = 64, activation = \"relu\") |>\n    layer_dense(units = 1, activation = \"sigmoid\")\n}\n\ndiscriminator() |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_disc\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_17 (Dense)                  │ (None, 64)               │           192 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_18 (Dense)                  │ (None, 1)                │            65 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 257 (1.00 KB)\n Trainable params: 257 (1.00 KB)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\nThe discriminator has two hidden layers with 32 and 16 units, respectively, and rectified linear activation functions. The output layer has a single unit and a sigmoid activation function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatent_dim <- as.integer(2)\nnsyn <- nrow(train_dat)\n\nmod <- gan(\n  discriminator = discriminator(dim = ncol(train_dat)), \n  generator = generator(latent_dim = latent_dim), \n  latent_dim = latent_dim\n)\n\nmod |>\n  compile(\n    d_optimizer = optimizer_rmsprop(),\n    g_optimizer = optimizer_rmsprop(),\n    loss_fn = loss_binary_crossentropy()\n  )\n\npar(mfrow = c(1, 2))\n\nfor (i in 1:2) {\n  mod |> fit(train_dat, epochs = i * 100, batch_size = 32, verbose = 0)\n  newdat <- as.matrix(mod$generator(tf$random$normal(shape = c(nsyn, latent_dim))))\n  plot(train_dat, col = \"darkorange2\", xlab = \"x1\", ylab = \"x2\")\n  points(newdat, col = \"darkgreen\", pch = 2)\n  contour(\n    x = seq(-2, 6, length = 100),\n    y = seq(-2, 6, length = 100),\n    z = matrix(mvtnorm::dmvnorm(expand.grid(x = seq(-2, 6, length = 100),\n                                            y = seq(-2, 6, length = 100)),\n                                mu, Sigma), nrow = 100),\n    add = TRUE\n  )\n}\n```\n\n::: {.cell-output-display}\n![Sample of synthetic data after training the GAN for 100 and 300 epochs.](index_files/figure-html/fig-bivariate-normal-gan-training-1.png){#fig-bivariate-normal-gan-training width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(train_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.978727 1.989606\n```\n\n\n:::\n\n```{.r .cell-code}\ncolMeans(newdat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.991835 1.963058\n```\n\n\n:::\n\n```{.r .cell-code}\nvar(train_dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]      [,2]\n[1,] 0.9975325 0.5019249\n[2,] 0.5019249 0.9751667\n```\n\n\n:::\n\n```{.r .cell-code}\nvar(newdat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]      [,2]\n[1,] 0.9464911 0.3714645\n[2,] 0.3714645 0.9200072\n```\n\n\n:::\n:::\n\n\nWhen inspecting the estimates, it can be seen that the means are estimated quite well, whereas the variances and covariances are somewhat underestimated (especially the covariances). However, when inspecting the contour lines of the true data generating distribution and the generated data (@fig-bivariate-normal-gan-training), it can be seen that the generated data is quite close to the true data generating distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontour(\n  x = seq(-2, 6, length = 100),\n  y = seq(-2, 6, length = 100),\n  z = matrix(mvtnorm::dmvnorm(expand.grid(x = seq(-2, 6, length = 100),\n                                          y = seq(-2, 6, length = 100)),\n                              mu, Sigma), nrow = 100)\n)\ncontour(\n  x = seq(-2, 6, length = 100),\n  y = seq(-2, 6, length = 100),\n  z = matrix(mvtnorm::dmvnorm(expand.grid(x = seq(-2, 6, length = 100),\n                                          y = seq(-2, 6, length = 100)),\n                              colMeans(newdat), var(newdat)), nrow = 100),\n  col = \"darkgreen\", add = TRUE\n)\n```\n\n::: {.cell-output-display}\n![Contour lines of the true data generating distribution (black lines) and the estimated distribution of the synthetic data (green lines, assuming a normal distribution).](index_files/figure-html/fig-bivariate-normal-synth-contours-1.png){#fig-bivariate-normal-synth-contours width=672}\n:::\n:::\n\n\n\n@fig-bivariate-normal-synth-contours shows the training data (orange points), the generated data (green points), and the contour lines of the true data generating distribution (black contour lines). The figure shows that there is quite some overlap between the observed and synthetic data.\n\n\n\n## Modeling a sin function\n\nNow we turn to a slightly more complex data generating distribution, in the sense that one of the variables comes from a univariate normal distribution, and the other variable follows a sine function of the first variable with some additive noise. The data generating distribution is given by\n$$\nf(x_1, x_2) = \\mathcal{N}(x_1; 2, 2) \\times \\mathcal{N}(x_2; \\sin(2x_1), 0.1).\n$$\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- rnorm(N, 2, 2)\nx2 <- rnorm(N, sin(2*x1), 0.1)\n\nplot(x1, x2, col = \"darkorange2\")\ncurve(sin(2*x), add = TRUE)\n```\n\n::: {.cell-output-display}\n![Realized training data (orange points) and the true data generating distribution (black line).](index_files/figure-html/fig-sin-data-1.png){#fig-sin-data width=672}\n:::\n:::\n\n\n@fig-sin-data shows the realized training data (orange points) and the conditional expectation $\\mathbb{E}(x_2|x_1)$ true data generating distribution (black line). We can now train a GAN on this data generating distribution. We start by defining the generator and discriminator architectures.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerator <- function(latent_dim = 1) {\n  model <- keras_model_sequential(input_shape = latent_dim, name = \"seq_gen\") |> \n    layer_dense(units = 8, activation = \"relu\") |>\n    layer_dense(units = 16, activation = \"relu\") |>\n    layer_dense(units = 32, activation = \"relu\") |>\n    layer_dense(units = 64, activation = \"relu\") |>\n    layer_dense(units = 2, activation = \"linear\")\n}\n\nsummary(generator())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_gen\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_22 (Dense)                  │ (None, 8)                │            16 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_23 (Dense)                  │ (None, 16)               │           144 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_24 (Dense)                  │ (None, 32)               │           544 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_25 (Dense)                  │ (None, 64)               │         2,112 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_26 (Dense)                  │ (None, 2)                │           130 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 2,946 (11.51 KB)\n Trainable params: 2,946 (11.51 KB)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\nThe generator has a single hidden layer with 16 units and rectified linear activation function, and an output layer with two units and linear activation function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminator <- function(dim = 2) {\n  model <- keras_model_sequential(input_shape = dim, name = \"seq_disc\") |> \n    layer_dense(units = 64, activation = \"relu\") |>\n    layer_dense(units = 32, activation = \"relu\") |> \n    layer_dense(units = 16, activation = \"relu\") |>\n    layer_dense(units = 1, activation = \"sigmoid\")\n}\n\nsummary(discriminator())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"seq_disc\"\n┌───────────────────────────────────┬──────────────────────────┬───────────────\n│ Layer (type)                      │ Output Shape             │       Param # \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_27 (Dense)                  │ (None, 64)               │           192 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_28 (Dense)                  │ (None, 32)               │         2,080 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_29 (Dense)                  │ (None, 16)               │           528 \n├───────────────────────────────────┼──────────────────────────┼───────────────\n│ dense_30 (Dense)                  │ (None, 1)                │            17 \n└───────────────────────────────────┴──────────────────────────┴───────────────\n Total params: 2,817 (11.00 KB)\n Trainable params: 2,817 (11.00 KB)\n Non-trainable params: 0 (0.00 B)\n```\n\n\n:::\n:::\n\n\nThe discriminator has two hidden layers with 32 and 16 units, respectively, and rectified linear activation functions. The output layer has a single unit and a sigmoid activation function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_dat <- cbind(x1, x2)\n\nlatent_dim <- as.integer(2)\nnsyn <- nrow(train_dat)\n\nmod <- gan(\n  discriminator = discriminator(dim = ncol(train_dat)),\n  generator = generator(latent_dim = latent_dim),\n  latent_dim = latent_dim\n)\n\nmod |>\n  compile(\n    d_optimizer = optimizer_rmsprop(),\n    g_optimizer = optimizer_rmsprop(),\n    loss_fn = loss_binary_focal_crossentropy()\n  )\n\npar(mfrow = c(2, 2))\n\nfor (i in 1:4) {\n  mod |> fit(train_dat, epochs = i^2*100, batch_size = 32, verbose = 0)\n  newdat <- as.matrix(mod$generator(tf$random$normal(shape = c(nsyn, latent_dim))))\n  plot(train_dat, col = \"darkorange2\", xlab = \"x1\", ylab = \"x2\")\n  points(newdat, col = \"darkgreen\", pch = 2)\n  curve(sin(2*x), add = TRUE)\n}\n```\n\n::: {.cell-output-display}\n![Training data (orange points) and the generated synthetic data (green points) after 100, 500, 900, and 2500 epochs, including the true model (black line).](index_files/figure-html/fig-sin-gan-training-1.png){#fig-sin-gan-training width=672}\n:::\n:::\n\n\n@fig-sin-gan-training shows the training data (orange points) and a realization of the synthetic data model after 100, 500, 900, and 2500 epochs (green points), including the conditional expectation of $x_2$ given $x_1$. The figure shows that the model slowly converges towards the real data distribution, although there seems to be some bias in some areas of the distribution. Also, the variance seems to be slightly underestimated in the synthetic data. Nevertheless, without providing any information about the true model, the synthetic data distribution is quite close to the true data generating distribution.\n\n## Conclusion\n\nThe examples shown here reveal that it is rather easy to construct a GAN to create synthetic data in R. However, without proper specifications of the hyperparameters, the quality of the synthetic data will be poor. Moreover, the examples show that the quality of the synthetic data can be substantially improved still. One might consider more advanced architectures of the generator or discriminator, changing the optimizer or loss function, or increasing the number of epochs. In any case, training a GAN to yield high-quality synthetic data is a non-trivial task that requires a lot of experimentation and tuning. Nevertheless, the examples show that GANs can be a powerful tool to create synthetic data that can be used for various purposes, such as data augmentation, privacy-preserving data sharing, or testing new algorithms on simulated data.\n\n\n## Reuse\n\n[GNU GPLv3](https://www.gnu.org/licenses/gpl-3.0.en.html)\n\n### Citation\n\n```{{bib}}\n@online{\n  author = {Volker, Thom Benjamin},\n  title = {Illustrative GANs for simple synthetic data with keras in R},\n  date = {2025-07-14},\n  url = {https://thomvolker.github.io/blog/1407_gans_in_r/}\n}\n```\n\nFor attribution, please cite this blogpost as:\n\n> Volker, T. B. (2025).\n> Illustrative GANs for simple synthetic data with keras in R.\n> Obtained from <https://thomvolker.github.io/blog/1407_gans_in_r/>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/grViz-binding-1.0.11/grViz.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}